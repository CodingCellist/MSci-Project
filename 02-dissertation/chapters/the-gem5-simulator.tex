\section{Overview}
The gem5 Simulator \cite{binkert_gem5_2011} is a state-of-the-art hardware 
simulator used not only for architecture research, but also by the companies 
which develop the hardware it simulates. ARM, for example, have detailed their 
use of it at the ARM research summit in 2017. It is the result of merging two 
simulators in 2011: the m5 simulator, which had great support for multiple 
hardware architectures and ISAs, and the GEMS simulator, whose main focus was 
memory simulation and hence allowed for detailed memory models and various 
cache coherence protocols \cite{binkert_gem5_2011}.

Due to the enormous complexity of such a piece of software, the way to start 
using gem5 is to download and build from source \cite{noauthor_gem5_nodate-2}. 
Building the simulator can be a bit complicated, due to it being sensitive to 
various system tools and configurations. The gem5 Simulator uses \texttt{scons} 
as its build tool. Specifically, it seems to rely on the Python 2 version of 
\texttt{scons} (and also uses Python 2 for its other Python scripts) despite 
Python 2 having been officially deprecated on the 1\textsuperscript{st} of 
January 2020, with the move to do so being announced well in advance 
\cite{noauthor_sunsetting_nodate}. However, this can be easily fixed by using a 
Python 2 virtual environment. The specific version of the GNU Compiler 
Collection (GCC) also seems to affect things. I was using GCC version 9.3.0 
which must have more warnings than the version used by the gem5 developers, as 
it failed to build gem5 due to the \texttt{-Werror} flag being turned on. This 
flags turns compiler warnings, which normally highlight suspicious areas of 
code but still lets the build go ahead, into errors which do not let the build 
go ahead. The user can tell the compiler that some warnings are exceptions to 
the \texttt{-Werror} flag, but due to the number of warnings I was getting, it 
was simpler to remove the flag from the \texttt{scons} configuration found in 
the \texttt{SConstruct} file. There are also a number of packages that the 
build script might recommend one installs, most notably the Google Performance 
Tools (gperftools) \cite{noauthor_google_nodate} which they suggest improves 
performance by 12\%. Once the necessary software, packages, etc. have been 
installed and configured, the build process takes around 20-30 minutes when 
building using 13 threads on an 8\textsuperscript{th} generation Intel Core i7 
processor, which also says something about the scale and complexity of gem5.

\section{Configuration and Setup}
    \subsection{The gem5 binary}
    There are two parts of gem5 that can be configured: the simulator binary 
    and its configuration files. The binary produced by \texttt{scons} supports 
    a number of flags which allow the user to specify things like the output 
    directory, whether to redirect gem5's standard output and/or standard error 
    streams, and what to call the various files being output. There are also 
    anumber of debug flags for developing gem5 itself. The most important of 
    the flags is arguably the \texttt{--outdir} flag used for specifying the 
    output directory. When running multiple simulations side by side, if no 
    directory is specified, i.e. the default \texttt{m5out} directory is used, 
    each instance will try to write to the same files as the others, resulting 
    in non-deterministic race conditions in terms of which process was the last 
    to write to the file, leading to unusable, interweaved output.

    \subsection{Python configuration scripts}
    After the flags, gem5 takes a Python script containing the setup(s) to run. 
    Since this is a regular Python script, it is possible to add command line 
    arguments here as well, allowing for control over the system configuration 
    without having to change the Python file itself. The gem5 Simulator comes 
    with a number of example scripts for ARM system simulation, located in the 
    \texttt{gem5/configs/example/arm} directory. The scripts provide examples 
    for syscall emulation, full system simulation, and full system simulation 
    with power models. Syscall emulation is faster than full system simulation 
    because it only simulates the system calls and their results, and not the 
    disks, memory, kernel, operating system, etc. Because of this, it is also 
    less precise. Full system simulation takes a while and requires a lot more 
    setup. The system has to be specified in its entirety: The full system (FS) 
    section of the ``Learning gem5'' book \cite{lowe-power_full_nodate} shows 
    how in order to run a full system simulation, the various caches, disks, 
    memory controllers, and North and South Bridges (for x86 system simulation) 
    have to be specified as Python objects. Fortunately, the 
    \texttt{devices.py} file in the example scripts directory already has all 
    of this implemented for ARM full system simulation. The example power model 
    script contains some very simple power models and is likely mainly to show 
    how the power models are specified and added to the objects that support 
    them. By default, the full system scripts support flags allowing to specify 
    the frequency and number of big and LITTLE cores; where the kernel, disk, 
    bootloader, and bootscript are located; whether to instantiate and simulate 
    caches; what CPU type to use; whether to restore from a checkpoint; and 
    much more.
    
    \subsection{Bootscripts, systems, and m5 instructions}
    \label{subsec:bootscripts-systems-m5}
    One of the arguments that must be passed to the simulated system (either 
    hardcoded in the Python configuration script or passed via a flag) is the 
    path to the bootscript to run once the OS has booted. The gem5 Simulator 
    comes with a couple of bootscripts, but these are for simulating distributed
    compute nodes, e.g. a compute cluster with multiple physical systems 
    collaborating and communicating over a network, and therefore contains a 
    lot of networking and other things that are unnecessary for this project. 
    However, it does provide some insight into how to write these. As far as I 
    can tell, even though the bootscripts all end in \texttt{.rcS}, the script 
    itself is simply a bash script with most of the usual bash builtins 
    supported. One slight complication is that the \texttt{PATH} environment 
    variable seems to always be unset so absolute paths to programs must be 
    specified rather than assuming they are available, e.g. you have to use 
    \texttt{/bin/ls} to list directory contents because \texttt{ls} is not on 
    the \texttt{PATH}.
    
    In order to simulate a full system, a kernel, disk, and bootloader must be
    provided. The gem5 website hosts a number of Linux disk images at
    \cite{noauthor_index_2020}. However, the gem5 website has recently been 
    modernised and in the process the file which displayed an index of 
    \cite{noauthor_index_2020} seems to have disappeared. Therefore the way to 
    get these system images is to use an old version of the m5 Simulator's 
    webpage \cite{noauthor_index_2017} which \textit{does} have an index, copy 
    the name of the file, and append it to the URL of 
    \cite{noauthor_index_2020}. This downloads the most recent version of the 
    system image from the official gem5 website rather than relying on the old 
    website(s) still being maintained. The system downloaded will typically 
    contain \texttt{disk} and \texttt{binaries} subdirectories. The 
    \texttt{disk} directory should contain a disk image (\texttt{.img}) file 
    with BusyBox \cite{noauthor_busybox_nodate} and an \texttt{init} process 
    pre-configured. It is possible to mount the disk image through a loopback 
    device on Linux, using the command
    \begin{lstlisting}
    sudo mount -o loop,offset=32256 \
        /path/to/disk-image.img /path/to/mountpoint
    \end{lstlisting}
    The \texttt{offset} specifies where the file system starts on the disk 
    image and is derived from 63 sectors $\times$ a 512-byte sector size. 
    Mounting the disk image can be useful in order to find or double-check the 
    absolute paths of certain programs for use in a bootscript, or to place 
    custom programs there in order to be able to run them in the simulator. One 
    crucial detail which seems to be missing in the gem5 documentation is that 
    in order for gem5 to be able to run the full system, the environment 
    variable \texttt{M5\_PATH} has to be exported to contain the absolute path 
    to the system files, i.e. the directory containing the `\texttt{binaries}' 
    and `\texttt{disks}' subdirectories. If \texttt{M5\_PATH} is not exported 
    to this, gem5 will error saying that the files were not found on the path; 
    there is no indication or mention of what path was searched. However, it is 
    documented in the ARM Research Starter Kit \cite{tousi_arm_2017}.
    
    The \texttt{m5} program, which is specific to interfacing with the simulator
    from within the simulated system, comes ``pre-installed'' on the 
    gem5-provided disk images. It is typically located at \texttt{/sbin/m5} and 
    is used to pass instructions to the simulator from within the simulated 
    system. If the program is run without passing any arguments, it will print 
    a list of the supported commands. The most useful one is \texttt{m5 
    checkpoint} which creates a checkpoint at the current simulation tick.
    
    \subsection{CPU types and checkpointing}
    By default, gem5 provides 3 CPU types for ARM system simulation: `timing',
    `atomic', and `exynos'. The last one likely refers to the Samsung Exynos 
    platform which may have special simulation requirements beyond the default 
    ARM systems. As we were not using this platform, I did not look further 
    into this setting. The `timing' and `atomic' CPU types have a key 
    difference: the atomic CPU type is a simplified CPU where every instruction 
    is atomic, i.e. it happens in one go and does not incur latency. This 
    results in much faster simulations (around 20 minutes to boot Linux 
    compared to around $1\frac{1}{2}$-2 hours using the timing CPU) at the cost 
    of 
    simulation realism. In reality, CPU instructions have a latency associated 
    with them, and so some instructions take longer than others. The timing CPU 
    models these latencies. As a result, it is a much more realistic simulation,
    at the cost of taking a lot longer to simulate.
    
    The atomic CPU type is extremely useful for ``fast-forwarding'' and 
    ``checkpointing''. As previously mentioned, running a full system 
    simulation with the timing CPU takes a long time to even get the operating 
    system booted. This is impractical if all we are interested in is the 
    program being run once the operating system has booted, e.g. if we are 
    running a benchmark, as only using the timing CPU would result in long wait 
    times due to a process that the researcher is not interested in. To mitigate
    this, gem5 allows the user to create and resume from checkpoints: stores of 
    exact system layout at a specific point in time, which can be used to resume
    the simulation from this state without needing to redo all the simulation 
    preceding it. When resuming from a checkpoint, the CPU type can be changed.
    This allows us to ``fast-forward'' parts of the system we are not interested
    in by using the atomic CPU and calling the \texttt{m5 checkpoint} 
    instruction from within the bootscript, before the line(s) where the 
    bootscript starts the benchmark.
    \begin{lstlisting}[language=bash, caption=Example bootscript using 
    checkpointing, basicstyle=\sffamily\footnotesize]
    #!/bin/bash
    
    echo "bootscript.rcS is running"
    
    /sbin/m5 checkpoint
    echo "Starting workload"
    /path/to/workload
    
    echo "Workload done, exiting simulation."
    /sbin/m5 exit
    \end{lstlisting}
    Once the bootscript has created the checkpoint, we can then interrupt the 
    simulation and restart it with the timing CPU using the \texttt{--cpu-type} 
    flag, and specify the path to the checkpoint to restore from using the 
    \texttt{--resume-from} flag. Unfortunately, it seems that the bootscript is 
    loaded into memory and hence stored along with the checkpoint, meaning 
    separate bootscripts have to be created and fast-forwarded for separate 
    workloads. Swapping the bootscript when resuming does not seem to have any 
    effect and the simulator will instead use the bootscript that was initially 
    passed to the simulator when fast-forwarding.
    
\section{Interacting with the simulated system}
It is possible to connect a terminal emulator to the simulated system and 
interact with it through this. The system's output is exposed on port 3456 by 
default, incrementing by 1 as simulations are run in parallel (i.e. 3457 for 
simulation 2, 3458 for simulation 3, etc.). Once option is to connect via the 
\texttt{telnet} command. However, gem5 also comes with a terminal emulator: 
\texttt{m5term}. The source code for it is found at \texttt{gem5/util/term/} 
and it needs to be compiled. Once \texttt{m5term} has been compiled, it can be 
connected to a system by running the command \texttt{./m5term <port>}, 
replacing \texttt{<port>} with the port number. For example, to log in to the 
simulated system, a bootscript containing the line \texttt{/sbin/getty 38400 
ttyAMA0} has to be used. This creates a login prompt which can then be used to 
log in using the username and password `root'. However, it is somewhat 
difficult to log in before the timout of 60 seconds occurs: key presses take a 
long time to be properly registered by the simulated system. Additionally, due 
to the complexity of running a full system simulation, the system is not the 
most responsive: tab completion takes around 30 seconds, simple commands like
\texttt{ls} take 10-20 seconds to execute, and it is possible to follow the 
line printing with the naked eye. Fast-forwarding and using custom bootscripts 
is the most straightforward and painless way to use the system.

\section{Cross Compilation}
In order to be able to compile and run custom experiments on the simulated 
system, a cross compiler is needed. The x86 system(s) running the simulator are 
based on a different ISA than ARM and so programs compiled for x86 will not run 
on ARM due to differences in the assembler and binary instructions. A cross 
compiler is a program which runs on one ISA and compiles programs for a 
different ISA, e.g. an x86 program which produces ARM binaries. The ARM 
Developer webpage provides a GNU toolchain which contains the entire GNU 
Compiler Collection, including cross compilers for x86 based systems 
\cite{noauthor_gnu_2019}. The systems I was examining were ARMv8, i.e. AArch64, 
systems so the {\sffamily aarch64-none-linux-gnu} cross compiler was used. I 
discovered that this cross compiler also produced binaries which were 
compatible with the Odroid N2 board and vice-versa: programs compiled on the 
Odroid N2 ran in the simulator when copied over to a disk image. Some programs, 
e.g. the Linux kernel, provide a \texttt{CROSS\_COMPILE} setting in the 
makefile, which can be set to instruct make to use the cross compilation 
toolchain instead of the host ISA's default toolchain, thereby facilitating 
cross compilation. The gem5 Simulator comes with two useful programs that may 
need cross compiling: ARM bootloaders and \texttt{m5}.

If setting up a different system from the provided ones, a bootloader is
required for full system simulation. The source code for ARM bootloaders is 
provided in \texttt{gem5/system/arm/bootloader/arm[64]/} for 32-bit ARMv7 and 
64-bit ARMv8 respectively. If additionally, a custom disk image is being 
prepared, the \texttt{m5} program used to interface with the simulator needs to 
be cross compiled and put on the image. The source code is found at 
\texttt{gem5/util/m5/} and for ARMv8, the \texttt{Makefile.aarch64} should be 
used.

\section{Power models and stats}
After getting gem5 to build and trying to learn how to set it up and use it, 
both through the ``Learning gem5'' book \cite{lowe-power_learning_2019} and by 
looking over the configuration scripts themselves, I decided to try to get the 
power models working, as power consumption was one of the main interest of the 
project. Whenever the provided \texttt{fs\_power.py} would be used as the 
configuration script, the simulator would crash right before starting the 
simulation, with the error message:
\begin{lstlisting}[basicstyle=\sffamily\footnotesize]
fatal: statistic '' (160) was not properly initialized by a regStats() function
\end{lstlisting}

I initially tried looking through documentation for both the ``Power and Thermal
Model'' \cite{noauthor_gem5_nodate-1} and the ``Stats package'' 
\cite{noauthor_gem5_nodate-3}. However, neither parts seemed to contain any 
hints as to what might be causing the crash. I also tried looking through the 
source code for the CPUs and the stats framework, but due to its scale (around 
13000 lines of code) and a lot of the code being C++ which I was not familiar 
with, this also did not solve or identify the problem.

On the 7\textsuperscript{th} of February, I raised an issue on the gem5 Jira 
pointing out that the script seemed to be broken \cite{hansen_gem5-319_2020} and
continued to look into DVFS, scheduling, and AMPs whilst waiting for a reply. My
supervisor also tried to get the script working. Just over a month later, some
of the gem5 developers got back. It turned out that they had been completely 
refactoring the way stats were done and registered, and as a result, certain 
simulated components were broken when trying to use features that relied on 
accessing the stats framework whilst a simulation was running, e.g. any 
subclass of the \texttt{MathExprPowerModel}. With one of the developers now 
being aware of the problem, an initial patch was provided within a day. After 
applying the patch and rebuilding gem5, the script managed to get past the 
initialisation step, but now crashed with the error:
\begin{lstlisting}[basicstyle=\sffamily\footnotesize]
warn: Failed to find stat 'dcache.overall_misses'
fatal: Failed to evaluate power expressions:
voltage * (2 * ipc + 3 * 0.000000001 * dcache.overall_misses / sim_seconds)
\end{lstlisting}
Based on the previous issue with registering stats, I assumed it might have been
something to do with not registering the stats the power expression was using, 
however, it turned out to be an additional bug due to the recent shift in the 
way gem5 was handling stats internally and a further patch was provided within 
a couple of days of getting back with the new error. With both patches applied, 
the \texttt{fs\_power.py} script ran without problems.

\section{Simulating PMUs}
Since PMUs are part of the ARM architecture, it would make sense for gem5 to 
simulate them. However, as far as I can tell, there is no documentation or 
guide as to where or how to access them. By looking through the provided 
\texttt{devices.py} script, the \texttt{CpuCluster} \textit{does} seem to add 
some PMU events to the system:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{screenshots/sim-pmu/devices-adds-pmus.png}
    \caption{\texttt{addPMUs} function found in \texttt{devices.py}}
\end{figure}
However, setting up a simple program which enables and accesses the PMUs did not
make any progress when run on the simulator with the function above being called
when initialising the system. The program never seemed to proceed, but when 
interrupting the simulator, the number of ticks was much greater than the 
observed average number of ticks to completely boot, indicating that the boot 
process had completed but the program was not running.

Taking a closer look at the \texttt{ArmPMU.py} source code (Figure 
\ref{fig:pmu-src}; found at\linebreak
\texttt{gem5/src/arch/arm/}) I discovered that very few of the PMU events 
seemed to be implemented. There was unfortunately also no hints in the code 
comments as to how to access or use the PMUs during the simulation. Looking 
through the relevant C++ files for \texttt{ArmPMU.py}, I discovered a 
`\texttt{//TODO}' at the PMU register which normally enables user access to the 
PMU registers. This, combined with the complete lack of documentation, seems to 
suggest the PMUs are unfortunately a work in progress and as such, I was unable 
to use them for my simulations.
\begin{figure}[H]
    %\vspace*{-2cm}
    \centering
    \begin{subfigure}{0.64\textwidth}
        \centering
        \includegraphics[width=\linewidth]{screenshots/sim-pmu/very-few.png}
        \caption{\texttt{ArmPMU.py}: Very few events seem to be implemented}
    \end{subfigure}
    \hfill
    \begin{subfigure}{0.35\textwidth}
        \centering
        \includegraphics[width=\linewidth]{screenshots/sim-pmu/pmu-todo.png}
        \caption{\texttt{pmu.cc}: The PMUs might be a work in progress}
    \end{subfigure}
    \caption{Looking through the PMU-relevant source code}
    \label{fig:pmu-src}
\end{figure}
    
\section{Customising the setups}
While the provided Python scripts help define almost everything, there are 
certain things that can be modelled which are not present in the scripts, due to
their already high complexity. In order to include these things in the 
simulation, it is therefore necessary to extend and/or modify the provided 
scripts.

    \subsection{Voltage and Frequency Domains}
    Part of this project was to look at whether scheduling and DVFS can be 
    combined to achieve more intelligent, power efficient schedules. Therefore, 
    we need the system we are simulating to have DVFS capabilities. In gem5, 
    adding DVFS to a simulation is done by assigning ``Frequency Domains'' to 
    certain objects. Since DVFS impacts the frequency, i.e. the clock speed, of 
    the object, any \texttt{ClockedObject} (which the CPU implementations are a 
    subclass of) can be assigned a Clock Domain. The documentation for adding 
    DVFS to a system is only available on the old website 
    \cite{noauthor_experimenting_2019} and it does not detail how to add DVFS 
    for the \texttt{fs\_bigLITTLE.py} configuration. In order to figure this 
    out, it is required to look at the script \textit{and} some of the gem5
    source code.
    \begin{lstlisting}[caption=Lines 42-52 from 
    \texttt{gem5/src/sim/VoltageDomain.py}, basicstyle=\sffamily\footnotesize,
    language=Python]
class VoltageDomain(SimObject):
    type = 'VoltageDomain'
    cxx_header = "sim/voltage_domain.hh"
    
    # Single or list of voltages for the voltage domain. If only a single
    # voltage is specified, it is used for all different frequencies.
    # Otherwise, the number of specified voltges and frequencies in the clock
    # domain (src/sim/ClockDomain.py) must match.  Voltages must be specified in
    # descending order. We use a default voltage of 1V to avoid forcing users to
    # set it even if they are not interested in using the functionality
    voltage = VectorParam.Voltage('1V', "Operational voltage(s)")
    \end{lstlisting}
    \begin{lstlisting}[caption=Lines 44-69 from 
    \texttt{gem5/src/sim/ClockDomain.py}, basicstyle=\sffamily\footnotesize,
    language=Python]
# Abstract clock domain
class ClockDomain(SimObject):
    type = 'ClockDomain'
    cxx_header = "sim/clock_domain.hh"
    abstract = True

# Source clock domain with an actual clock, and a list of voltage and frequency
# op points
class SrcClockDomain(ClockDomain):
    type = 'SrcClockDomain'
    cxx_header = "sim/clock_domain.hh"
    
    # Single clock frequency value, or list of frequencies for DVFS
    # Frequencies must be ordered in descending order
    # Note: Matching voltages should be defined in the voltage domain
    clock = VectorParam.Clock("Clock period")
    
    # A source clock must be associated with a voltage domain
    voltage_domain = Param.VoltageDomain("Voltage domain")
    
    # Domain ID is an identifier for the DVFS domain as understood by the
    # necessary control logic (either software or hardware). For example, in
    # case of software control via cpufreq framework the IDs should correspond
    # to the neccessary identifier in the device tree blob which is interpretted
    # by the device driver to communicate to the domain controller in hardware.
    domain_id = Param.Int32(-1, "domain id")
    \end{lstlisting}
    By examining the source code of the Voltage and Clock Domain objects, we 
    discover several things not apparent in the guide/documentation:
    \begin{enumerate}
        \item Voltage and frequency points have to be specified in sorted,
              descending order.
        \item There can either be one voltage value for all frequency steps or
              there must be exactly the same number of voltage and frequency 
              steps.
        \item Clock domains have an ID which must be unique.
    \end{enumerate}

    When looking at the provided system devices in 
    \texttt{gem5/configs/example/arm/devices.py}, the \texttt{CpuCluster} 
    constructor already has constructor support for specifying voltage and 
    clock domains.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{screenshots/cpu-cluster-constructor.png}
        \caption{The \texttt{CpuCluster} constructor}
    \end{figure}
%    \begin{lstlisting}[caption=The \texttt{CpuCluster} constructor, 
%    language=Python, basicstyle=\sffamily\footnotesize]
%class CpuCluster(SubSystem):
%    def __init__(self, system,  num_cpus, cpu_clock, cpu_voltage,
%                 cpu_type, l1i_type, l1d_type, wcache_type, l2_type):
%    \end{lstlisting}
    Passing a list of values to the \texttt{cpu\_clock} and 
    \texttt{cpu\_voltage} arguments constructs the relevant objects inside the 
    \texttt{CpuCluster} object. The only part that needs changing is that the 
    clock domains are not given an ID. This causes the simulator to crash, as 
    the logic detects that the default ID of $-1$ was given and errors with a 
    message explaining that clock domains must have a unique ID. As part of the 
    project, an Odroid N2 board was acquired. By examining its DVFS capabilities
    using the \texttt{cpupower} tool, it seems the most common setup is to have
    one DVFS domain per cluster, i.e. per big and LITTLE `part' of the setup.
    Therefore, I change the line initialising the voltage domain to assign an ID
    based on the number of clusters in the system. This will return 0 for the 
    first cluster, i.e. cluster 0, and 1 for the second cluster.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{screenshots/cpu-cluster-clock-domain-assignment.png}
        \caption{Modified line 126 of \texttt{devices.py}}
    \end{figure}
%    \begin{lstlisting}[caption=Modified line 126 of \texttt{devices.py}, 
%    language=Python, basicstyle=\sffamily\footnotesize]
%    self.clk_domain = SrcClockDomain(clock=cpu_clock,
%                                     voltage_domain=self.voltage_domain,
%                                     domain_id=system.numCpuClusters())
%    \end{lstlisting}
    
    With the devices modified to correctly set up the DVFS objects in the 
    simulator, the only thing that remains to be changed is the 
    \texttt{fs\_bigLITTLE.py} file. In an attempt to model DVFS as realistically
    as possible, I used clock and voltage steps from the Odroid N2 board that
    was provided for this project. The clock steps were collected through the 
    \texttt{cpupower} tool. The voltage steps were harder figure out where to 
    find. It turns out that Linux provides some insight into the voltage values 
    through the sysfs, i.e. the \texttt{/sys} file system. There are a number of
    voltage regulators at \texttt{/sys/class/regulator/regulator.\{0,1,2\}}. By 
    using the \texttt{userspace} frequency governor, which scales the frequency 
    to whatever the user specifies, and the \texttt{cpupower} tool to adjust 
    the frequency, I was able to narrow down that regulators 1 and 2 control 
    the voltage of the LITTLE and big clusters respectively. Regulator 0
    seems to not do anything, as running \texttt{cat} on the 
    \texttt{regulator.0/name} outputs the value ``\texttt{regulator-dummy}'', 
    indicating that the regulator is unlikely to control anything.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{screenshots/odroid-stuff/regulator-names.png}
        \caption{The names of the regulators on the Odroid N2 board}
    \end{figure}

    In order to model the different DVFS steps for the big and LITTLE clusters,
    I extended the \texttt{CpuCluster} class into 2 clusters: 
    \texttt{DVFSBigCluster} and \texttt{DVFSLittleCluster}. These subclasses 
    were configured identically to the existing \texttt{BigCluster} and 
    \texttt{LittleCluster} classes, with the exception of specifying different 
    voltage and clock domains in each one. I also extended the 
    \texttt{AtomicCluster} class into a \texttt{DVFSBigAtomicCluster} and 
    \texttt{DVFSLittleAtomicCluster} class, in order to be able to fast-forward 
    the systems. The changes were made in a copy of the 
    \texttt{fs\_bigLITTLE.py} file: \texttt{fs\_bL\_extended.py}.
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.45\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/config-exts/dvfs-big-cluster.png}
            \caption{DVFS values for the big cluster}
        \end{subfigure}
        \begin{subfigure}{0.45\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/config-exts/dvfs-little-cluster.png}
            \caption{DVFS values for the LITTLE cluster}
        \end{subfigure}
        \caption{DVFS setups based on the Odroid N2 board}
    \end{figure}
    
    Finally, to wire everything up in the script and be able to use the
    clusters, big.LITTLE pairs of the clusters were added to the 
    \texttt{cpu\_types} dictionary, allowing them to be selected through the
    \texttt{--cpu-type} flag, and as shown in one of examples in the old 
    documentation \cite{noauthor_experimenting_2019}, the system's DVFS-handler
    was configured and enabled in cases where the DVFS clusters were being used.
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.9\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/config-exts/cpu-types.png}
            \caption{The DVFS clusters included in \texttt{cpu\_types}}
        \end{subfigure}
        \begin{subfigure}{0.9\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/config-exts/dvfs-handler.png}
            \caption{If DVFS models are used, configure and enable the DVFS 
                     handler}
        \end{subfigure}
        \caption{Extensions made to be able to use the DVFS extensions}
    \end{figure}
    
    \subsection{Power Models}\label{subsec:ext-power-mods}
    The example power models provided with gem5 are explicitly labelled as toy
    models: when using the \texttt{fs\_power.py} script, the script will print a
    warning to the user that ``The power numbers generated by this script are 
    examples. They are not representative of any particular implementation or 
    process''. However, the script provides a good overview of how to add custom
    power models. Power models consist of four functions, each describing how
    to calculate the power consumption in a different power state. The provided 
    example script only assigns a power model to the \texttt{ON} power state and
    assigns a simple function returning 0 to the other states. Although each
    power state is labelled with a comment, the explanations of what the power
    states mean can only be found by looking at the \texttt{ClockedObject.py}
    source code:
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{screenshots/power-states/details.png}
        \caption{Lines 42-58 of \texttt{ClockedObject.py}, explaining the
                 possible power states}
    \end{figure}
    Based on the \texttt{fs\_power.py} script, the functions for modelling power
    extend the \texttt{MathExprPowerModel} class. The 
    \texttt{MathExprPowerModel} class allows the equations to use the stats 
    being recorded by gem5, e.g. instructions per cycle, for computing the 
    power consumption \cite{bischoff_gem5_2017-1} and contains two equations: 
    \texttt{dyn} and \texttt{st}. These represent the dynamic and static power 
    consumptions of the system, respectively. The static power is the power that
    the component is consuming in the background, i.e. `statically', and the
    dynamic power is the power consumption which changes `dynamically' depending
    on what the system is doing. Since we are interested in whether DVFS and 
    scheduling can result in power savings, we need to define power models so 
    that gem5 can simulate and output power readings.
    
    A paper published in 2018 by Walker et al. 
    \cite{walker_hardware-validated_2018} presents a tool called `gemstone' 
    which can be used for more accurate power modelling. Specifically, the 
    `gemstone-applypower' tool \cite{walker_mattw200gemstone-applypower_2018}
    can automatically generate power equations which can be used in gem5, based
    on the data collected in \cite{walker_hardware-validated_2018}. Using this 
    tool, I created the \texttt{fs\_bL\_power\_models.py} file to create and
    easily import the power models generated by 
    \cite{walker_mattw200gemstone-applypower_2018}. Since one of the big 
    advantages of using a simulator is that the core configurations can be 
    changed, I customised the power models based on how many cores were 
    available, and created new \texttt{MathExprPowerModel} subclasses for each 
    core configuration, e.g. \texttt{BigCpuA15x4PowerOn} or 
    \texttt{LittleCpuA7x2PowerOn} for 4 big and 2 LITTLE cpus respectively. The 
    CPUs in the Odroid N2 board are not A15 and A7 cores, but instead A73 and 
    A53 cores. Additionally, modifying equations which were based on hardware 
    readings from a board with a 4 big, 4 LITTLE (4b4L) configuration is 
    unlikely to be accurate. However, the modified power equations should still 
    be better than the toy models provided by the gem5 example script as they 
    take many more factors into account, e.g. the current clock frequency, 
    certain floating point operations, the number of cycles that was simulated, 
    etc. With the various power models in one file, they could be imported and 
    the script configured to apply them based on the number of CPUs specified, 
    using a helper function to make sure the power models were applied to all 
    the CPUs in the cluster:
    \begin{figure}[H]
        \centering
        \begin{subfigure}{0.9\linewidth}
            \centering
            \includegraphics[width=0.4\textwidth]{screenshots/config-exts/def-apply-pm.png}
            \caption{Helper function to apply power models to all CPUs in the 
                     cluster.}
        \end{subfigure}
        \begin{subfigure}{0.9\linewidth}
            \centering
            \includegraphics[width=0.7\textwidth]{screenshots/config-exts/apply-power-models.png}
            \caption{Applying power models based on no. CPUs}
        \end{subfigure}
        \caption{Extending \texttt{fs\_bL\_extended.py} to apply power models}
    \end{figure}
    Finally, in order to keep the \texttt{fs\_bL\_extended.py} script as 
    flexible as possible, I added a \texttt{--power-models} flag which would 
    toggle the code block applying the power models instead of always trying to
    apply them. This was necessary, as the power models only work with the 
    detailed `timing' CPU type.
    
    \subsection{Output resolution}
    By default, gem5 dumps simulation statistics every simulated second. The 
    statistics, found in the \texttt{outdir/stats.txt} file, contain numerous 
    insights and measurements, including memory bus packet sizes, number of 
    floating point units used, number of instructions committed, and much more. 
    It is possible to adjust how often gem5 dumps these stats, by using the 
    \texttt{m5.stats.periodicStatDump} function in the Python configuration 
    script. The function takes a period in simulated ticks, but gem5 provides a 
    function \texttt{m5.ticks.fromSeconds} to easily be able to specify the 
    frequency in seconds and then convert it to simulated ticks.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.6\linewidth]{screenshots/config-exts/periodic-dump-stats.png}
        \caption{Lines 129-130 from \texttt{fs\_power.py}, demonstrating how to 
                 control the stats dump frequency}
    \end{figure}
    In \cite{bischoff_gem5_2017-1} slide 16 (Figure 
    \ref{fig:bischoff-gem5-s16}), it is shown how drastically different stats 
    dump frequency can affect the resolution of power models. Therefore, I 
    added a \texttt{--stat-freq} flag to the \texttt{fs\_bL\_extended.py} 
    script, which allows the user to specify how frequently gem5 should dump 
    stats, including support for scientific notation, e.g. {\sffamily 1e$-$3} 
    for milliseconds.
    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\linewidth]{screenshots/empowering-the-masses-s16.png}
        \caption{Slide 16 from \cite{bischoff_gem5_2017-1}}
        \label{fig:bischoff-gem5-s16}
    \end{figure}

\section{Stats access from power models}
After importing the power models generated by 
\cite{walker_mattw200gemstone-applypower_2018} and setting up the scripts as
detailed in Section \ref{subsec:ext-power-mods}, the majority of the stats 
being used in the more detailed power models were unable to be found by the 
simulator. This was somewhat perplexing as the exact strings used in the 
power expressions were present in the \texttt{stats.txt} output when a 
simulation was run without the power models enabled. Trying once more to 
look through the power \cite{noauthor_gem5_nodate-1} and stats 
\cite{noauthor_gem5_nodate-3} documentation did not lead anywhere since the 
documentation does not detail which stats might exist or how to correctly 
access them. Unfortunately, I had managed to time the project at the same 
time that gem5 was migrating their website to a new one and as such, a lot 
of the documentation was missing or not in the places one would expect to 
find it. Furthermore, it turned out that the DVFS documentation was 
officially labelled out of date \cite{noauthor_gem5_nodate} and trying to 
look through more of the documentation revealed a similar pattern. Many 
pages would have a disclaimer at their top saying that they were from the 
old website and might be outdated as a result.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{screenshots/gem5-docs-disclaimer.png}
    \caption{Disclaimer initially found on many documentation pages due to 
        their recent migration from the old website}
\end{figure}

Looking at the \texttt{MathExprPowerModel} source code (Figure 
\ref{fig:relative-stat-paths}) suggested that the stat names used possibly 
had to be relative to the simulated object that was referencing them. This 
led me to try to print the output of the \texttt{getStatGroups} and 
\texttt{getStats} functions which were associated with each 
\texttt{SimObject}. The results of this can be seen in Appendix 
\ref{ch:power-model-eldritch}. However, this just seemed to confirm that 
the stats the simulator was crashing on \textit{were} present. Trying to 
specify `relative' stats, e.g. replacing the use of
\\
\texttt{system.bigCluster.clk\_domain.clock}
\\
with \texttt{clk\_domain.clock} or \texttt{Parent.clk\_domain.clock} (both 
of which seemed sensible based on the outputs from the \texttt{getStats} and
\texttt{getStatGroups} functions), did not solve the problem and still 
caused the simulator to crash, now specifying the renamed attempts as the 
stats not being found. As it was unclear which objects could be assigned a 
power model, and given that the expressions generated by 
\cite{walker_mattw200gemstone-applypower_2018} seemed to specify the full 
`path', I decided to try assigning the power models to the top-level 
\texttt{system} object and I also tried to assign power models to the 
clusters. Neither solved the problem: assigning the power model to the 
system caused the simulator to error in a different way, and assigning them 
to the clusters caused it to segfault.
\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{screenshots/power-model-eldritchness/MathExprPowerModel-RelativeStatPath.png}
    \caption{A comment in the source code mentions that stats may have to 
        be relative to the \texttt{SimObject} they are being used with}
    \label{fig:relative-stat-paths}
\end{figure}

My next idea was that this might have something to do with the new stats 
framework and the \texttt{regStats} function which had been the source of 
previous problems. However, as far as I was able to tell, there is no 
documentation of what stats are registered by the various objects. In order 
to find this out, one has to find the \texttt{regStats} function in the C++ 
source code relevant to the \texttt{SimObject} in question. Furthermore, 
some knowledge of the object hierarchy is required as stats registered in a 
superclass are available to the power models in a subclass. One of the stats
that was not mentioned in the gem5 crash messages was the \texttt{numCycles}
stat. This stat is registered by the \texttt{BaseCpu} class and was
referable exactly as registered: by the \texttt{numCycles} string. Once I
found the source code for the voltage and clock domains (located in 
\texttt{gem5/src/sim/power/}) I discovered that they \textit{did} seem to 
register the stats that the simulator claimed to be unable to find.
\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\textwidth]{screenshots/have-to-search-src-for-regStats/base-cpu-cc-regStats.png}
        \caption{Stats registered by \texttt{BaseCpu}}
    \end{subfigure}
    \hfil
    \begin{minipage}[b]{0.45\textwidth}
        \begin{subfigure}[b]{\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/have-to-search-src-for-regStats/voltage-domain-registers-a-stat.png}
            \caption{Stats registered by \texttt{VoltageDomain}}
        \end{subfigure}
        \\[\baselineskip]
        \begin{subfigure}[b]{\linewidth}
            \centering
            \includegraphics[width=\textwidth]{screenshots/have-to-search-src-for-regStats/clock-domain-registers-a-stat.png}
            \caption{Stats registered by \texttt{ClockDomain}}
            \label{subfig:clk-dom-regStats}
        \end{subfigure}
    \end{minipage}
    \caption{Various \texttt{regStats} functions searched to find stat 
        names}
    \label{fig:regstats-search}
\end{figure}

Having exhausted every attempt at finding and fixing what I presumed was a 
simple issue, I opened another issue on the gem5 Jira 
\cite{hansen_gem5-463_2020}. As this was now very close to the project 
deadline, I reverted back to using the toy power models because whilst not 
hardware-validated, they did produce power output which varied depending on 
the workload and DVFS state of the system, and getting some results was a 
very high priority. I also looked into potentially using a completely 
different simulator, in order to get any results. As I did not expect to 
get an answer immediately or to necessarily have the developers be able to 
solve it in an instant, I set up the experiments described in Chapter 
\ref{ch:experimental-setup} as soon as possible.

I received a response to the issue the next day along with a pointer to 
some existing patches which could be possible solutions. However, these had 
merge conflicts with the previous patches that were applied to fix the 
\texttt{regStats} bug and eventually, by discussing the issue with the 
developer helping me, we found out that it was not a problem with the 
simulator but with the naming of the stats. The stat that the power 
expression was trying to reference was \texttt{clk\_domain.clock}. Based on 
both the \texttt{stats.txt} output and the clock domain's \texttt{regStats} 
function, this seemed to be the name of the stat. Instead, it turns out 
that the current clock value can be is accessed through the string 
\texttt{clock\_period}. This parameter only appears internally in the 
\texttt{clock\_domain.cc} file, where it is assigned to the 
\texttt{\_clockPeriod} field (see Figure \ref{fig:clock-period-src}), which 
is then used in the \texttt{regStats} method (see Figure 
\ref{subfig:clk-dom-regStats}). Other than this, there is no indication 
anywhere that this might be the stat name. Unfortunately, as I was busy 
trying to get any results ready and refactoring all the power equations 
would have taken some time, this solution never made it into the project.
\begin{figure}[H]
    \centering
    \includegraphics[width=0.85\textwidth]{screenshots/power-model-eldritchness/clock-period-src.png}
    \caption{Only uses of the \texttt{\_clockPeriod} field}
    \label{fig:clock-period-src}
\end{figure}

\section{Looking into a different simulator}
Having seemingly exhausted most options for getting power output from gem5, my 
supervisor suggested that we try using the Sniper Simulator 
\cite{carlson_sniper_2011,carlson_evaluation_2014} due to its claims of having 
``[f]ull DVFS support'' \cite{noauthor_sniper_2020}. Sniper is only for x86 
simulation and not ARM, but it could still have been useful. Unfortunately, it 
was impossible to get it to build. Version 7.2, the version available when 
looking into it, failed to build despite trying different versions of the Intel 
PIN tool that it depends on \cite{noauthor_getting_2019} and looking at the 
Google Groups error reporting, it seemed this was a common problem, even with 
the Docker image \cite{noauthor_error_2020}. Because of this, and because the 
toy power models in gem5 seemed to work, no further attempts to get Sniper 
working were made.
